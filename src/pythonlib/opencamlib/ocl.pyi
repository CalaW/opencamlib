"""
OpenCAMLib docstring
"""
from __future__ import annotations
import pybind11_stubgen.typing_ext
import typing
__all__ = ['AdaptivePathDropCutter', 'AdaptiveWaterline', 'Arc', 'ArcSpanType', 'BallConeCutter', 'BallCutter', 'BatchDropCutter', 'BatchPushCutter', 'Bbox', 'BullConeCutter', 'BullCutter', 'CCPoint', 'CCType', 'CLPoint', 'CompBallCutter', 'CompCylCutter', 'ConeConeCutter', 'ConeCutter', 'CutterLocationSurface', 'CylConeCutter', 'CylCutter', 'EDGE', 'EDGE_BALL', 'EDGE_CONE', 'EDGE_CONE_BASE', 'EDGE_CYL', 'EDGE_HORIZ', 'EDGE_HORIZ_CYL', 'EDGE_HORIZ_TOR', 'EDGE_NEG', 'EDGE_POS', 'EDGE_SHAFT', 'ERROR', 'Ellipse', 'EllipsePosition', 'FACET', 'FACET_CYL', 'FACET_TIP', 'Fiber', 'Interval', 'Line', 'LineCLFilter', 'LineSpanType', 'MillingCutter', 'NONE', 'Path', 'PathDropCutter', 'Point', 'STLReader', 'STLSurf', 'SimpleWeave', 'SmartWeave', 'SpanType', 'TSPSolver', 'Triangle', 'VERTEX', 'VERTEX_CYL', 'Waterline', 'Weave', 'WeaveVertexType', 'ZigZag', 'eps', 'epsD', 'epsF', 'max_threads', 'version']
class AdaptivePathDropCutter:
    minimumZ: float
    def __init__(self) -> None:
        ...
    def getCLPoints(self) -> list[CLPoint]:
        ...
    def getSampling(self) -> float:
        ...
    def getZ(self) -> float:
        ...
    def run(self) -> None:
        ...
    def setCosLimit(self, arg0: float) -> None:
        ...
    def setCutter(self, arg0: MillingCutter) -> None:
        ...
    def setMinSampling(self, arg0: float) -> None:
        ...
    def setPath(self, arg0: Path) -> None:
        ...
    def setSTL(self, arg0: STLSurf) -> None:
        ...
    def setSampling(self, arg0: float) -> None:
        ...
    def setZ(self, arg0: float) -> None:
        ...
class AdaptiveWaterline:
    def __init__(self) -> None:
        ...
    def getLoops(self) -> list[list[Point]]:
        ...
    def getThreads(self) -> int:
        ...
    def getXFibers(self) -> list[Fiber]:
        ...
    def getYFibers(self) -> list[Fiber]:
        ...
    def reset(self) -> None:
        ...
    def run(self) -> None:
        ...
    def run2(self) -> None:
        ...
    def setCutter(self, arg0: MillingCutter) -> None:
        ...
    def setMinSampling(self, arg0: float) -> None:
        ...
    def setSTL(self, arg0: STLSurf) -> None:
        ...
    def setSampling(self, arg0: float) -> None:
        ...
    def setThreads(self, arg0: int) -> None:
        ...
    def setZ(self, arg0: float) -> None:
        ...
class Arc:
    c: Point
    dir: bool
    p1: Point
    p2: Point
    @typing.overload
    def __init__(self, arg0: Point, arg1: Point, arg2: Point, arg3: bool) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Arc) -> None:
        ...
class BallConeCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
class BallCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def dropCutterSTL(self, arg0: CLPoint, arg1: STLSurf) -> bool:
        ...
class BatchDropCutter:
    def __init__(self) -> None:
        ...
    def appendPoint(self, arg0: CLPoint) -> None:
        ...
    def getBucketSize(self) -> int:
        ...
    def getCLPoints(self) -> list[CLPoint]:
        ...
    def getCalls(self) -> int:
        ...
    def getThreads(self) -> int:
        ...
    def getTrianglesUnderCutter(self, arg0: CLPoint, arg1: MillingCutter) -> list[Triangle]:
        ...
    def run(self) -> None:
        ...
    def setBucketSize(self, arg0: int) -> None:
        ...
    def setCutter(self, arg0: MillingCutter) -> None:
        ...
    def setSTL(self, arg0: STLSurf) -> None:
        ...
    def setThreads(self, arg0: int) -> None:
        ...
class BatchPushCutter:
    def __init__(self) -> None:
        ...
    def appendFiber(self, arg0: Fiber) -> None:
        ...
    def getBucketSize(self) -> int:
        ...
    def getCLPoints(self) -> list[CLPoint]:
        ...
    def getCalls(self) -> int:
        ...
    def getFibers(self) -> list[Fiber]:
        ...
    def getOverlapTriangles(self, arg0: Fiber) -> list[Triangle]:
        ...
    def getThreads(self) -> int:
        ...
    def run(self) -> None:
        ...
    def setBucketSize(self, arg0: int) -> None:
        ...
    def setCutter(self, arg0: MillingCutter) -> None:
        ...
    def setSTL(self, arg0: STLSurf) -> None:
        ...
    def setThreads(self, arg0: int) -> None:
        ...
    def setXDirection(self) -> None:
        ...
    def setYDirection(self) -> None:
        ...
class Bbox:
    def isInside(self, arg0: Point) -> bool:
        ...
    @property
    def maxpt(self) -> Point:
        ...
    @property
    def minpt(self) -> Point:
        ...
class BullConeCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
class BullCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
class CCPoint(Point):
    type: CCType
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CCPoint) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    def __str__(self) -> str:
        ...
class CCType:
    """
    Members:
    
      NONE
    
      VERTEX
    
      VERTEX_CYL
    
      EDGE
    
      EDGE_SHAFT
    
      EDGE_HORIZ
    
      EDGE_CYL
    
      EDGE_BALL
    
      EDGE_CONE
    
      EDGE_CONE_BASE
    
      EDGE_HORIZ_CYL
    
      EDGE_HORIZ_TOR
    
      EDGE_POS
    
      EDGE_NEG
    
      FACET
    
      FACET_TIP
    
      FACET_CYL
    
      ERROR
    """
    EDGE: typing.ClassVar[CCType]  # value = <CCType.EDGE: 3>
    EDGE_BALL: typing.ClassVar[CCType]  # value = <CCType.EDGE_BALL: 8>
    EDGE_CONE: typing.ClassVar[CCType]  # value = <CCType.EDGE_CONE: 12>
    EDGE_CONE_BASE: typing.ClassVar[CCType]  # value = <CCType.EDGE_CONE_BASE: 13>
    EDGE_CYL: typing.ClassVar[CCType]  # value = <CCType.EDGE_CYL: 11>
    EDGE_HORIZ: typing.ClassVar[CCType]  # value = <CCType.EDGE_HORIZ: 4>
    EDGE_HORIZ_CYL: typing.ClassVar[CCType]  # value = <CCType.EDGE_HORIZ_CYL: 6>
    EDGE_HORIZ_TOR: typing.ClassVar[CCType]  # value = <CCType.EDGE_HORIZ_TOR: 7>
    EDGE_NEG: typing.ClassVar[CCType]  # value = <CCType.EDGE_NEG: 10>
    EDGE_POS: typing.ClassVar[CCType]  # value = <CCType.EDGE_POS: 9>
    EDGE_SHAFT: typing.ClassVar[CCType]  # value = <CCType.EDGE_SHAFT: 5>
    ERROR: typing.ClassVar[CCType]  # value = <CCType.ERROR: 17>
    FACET: typing.ClassVar[CCType]  # value = <CCType.FACET: 14>
    FACET_CYL: typing.ClassVar[CCType]  # value = <CCType.FACET_CYL: 16>
    FACET_TIP: typing.ClassVar[CCType]  # value = <CCType.FACET_TIP: 15>
    NONE: typing.ClassVar[CCType]  # value = <CCType.NONE: 0>
    VERTEX: typing.ClassVar[CCType]  # value = <CCType.VERTEX: 1>
    VERTEX_CYL: typing.ClassVar[CCType]  # value = <CCType.VERTEX_CYL: 2>
    __members__: typing.ClassVar[dict[str, CCType]]  # value = {'NONE': <CCType.NONE: 0>, 'VERTEX': <CCType.VERTEX: 1>, 'VERTEX_CYL': <CCType.VERTEX_CYL: 2>, 'EDGE': <CCType.EDGE: 3>, 'EDGE_SHAFT': <CCType.EDGE_SHAFT: 5>, 'EDGE_HORIZ': <CCType.EDGE_HORIZ: 4>, 'EDGE_CYL': <CCType.EDGE_CYL: 11>, 'EDGE_BALL': <CCType.EDGE_BALL: 8>, 'EDGE_CONE': <CCType.EDGE_CONE: 12>, 'EDGE_CONE_BASE': <CCType.EDGE_CONE_BASE: 13>, 'EDGE_HORIZ_CYL': <CCType.EDGE_HORIZ_CYL: 6>, 'EDGE_HORIZ_TOR': <CCType.EDGE_HORIZ_TOR: 7>, 'EDGE_POS': <CCType.EDGE_POS: 9>, 'EDGE_NEG': <CCType.EDGE_NEG: 10>, 'FACET': <CCType.FACET: 14>, 'FACET_TIP': <CCType.FACET_TIP: 15>, 'FACET_CYL': <CCType.FACET_CYL: 16>, 'ERROR': <CCType.ERROR: 17>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CLPoint(Point):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CLPoint) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: CCPoint) -> None:
        ...
    def __str__(self) -> str:
        ...
    def cc(self) -> CCPoint:
        ...
    def getCC(self) -> CCPoint:
        ...
class CompBallCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
class CompCylCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
class ConeConeCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
class ConeCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
class CutterLocationSurface:
    def __init__(self, arg0: float) -> None:
        ...
    def __str__(self) -> str:
        ...
    def getEdges(self) -> list[tuple[Point, Point]]:
        ...
    def getVertices(self) -> list[Point]:
        ...
    def run(self) -> None:
        ...
    def setCutter(self, arg0: MillingCutter) -> None:
        ...
    def setMinSampling(self, arg0: float) -> None:
        ...
    def setSTL(self, arg0: STLSurf) -> None:
        ...
    def setSampling(self, arg0: float) -> None:
        ...
class CylConeCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
class CylCutter(MillingCutter):
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def dropCutterSTL(self, arg0: CLPoint, arg1: STLSurf) -> bool:
        ...
class Ellipse:
    def __init__(self, arg0: Point, arg1: float, arg2: float, arg3: float) -> None:
        ...
    def ePoint(self, arg0: EllipsePosition) -> Point:
        ...
    def normal(self, arg0: EllipsePosition) -> Point:
        ...
    def oePoint(self, arg0: EllipsePosition) -> Point:
        ...
class EllipsePosition:
    s: float
    t: float
    def __str__(self) -> str:
        ...
    def setDiangle(self, arg0: float) -> None:
        ...
class Fiber:
    def __init__(self, arg0: Point, arg1: Point) -> None:
        ...
    def addInterval(self, arg0: Interval) -> None:
        ...
    def getInts(self) -> list[Interval]:
        ...
    def point(self, arg0: float) -> Point:
        ...
    def printInts(self) -> None:
        ...
    @property
    def dir(self) -> Point:
        ...
    @property
    def p1(self) -> Point:
        ...
    @property
    def p2(self) -> Point:
        ...
class Interval:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def __str__(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def updateLower(self, arg0: float, arg1: CCPoint) -> None:
        ...
    def updateUpper(self, arg0: float, arg1: CCPoint) -> None:
        ...
    @property
    def lower(self) -> float:
        ...
    @property
    def lower_cc(self) -> CCPoint:
        ...
    @property
    def upper(self) -> float:
        ...
    @property
    def upper_cc(self) -> CCPoint:
        ...
class Line:
    p1: Point
    p2: Point
    @typing.overload
    def __init__(self, arg0: Point, arg1: Point) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Line) -> None:
        ...
class LineCLFilter:
    def __init__(self) -> None:
        ...
    def addCLPoint(self, arg0: CLPoint) -> None:
        ...
    def getCLPoints(self) -> list[CLPoint]:
        ...
    def run(self) -> None:
        ...
    def setTolerance(self, arg0: float) -> None:
        ...
class MillingCutter:
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        ...
    def dropCutter(self, arg0: CLPoint, arg1: Triangle) -> bool:
        ...
    def edgeDrop(self, arg0: CLPoint, arg1: Triangle) -> bool:
        ...
    def facetDrop(self, arg0: CLPoint, arg1: Triangle) -> bool:
        ...
    def getDiameter(self) -> float:
        ...
    def getLength(self) -> float:
        ...
    def getRadius(self) -> float:
        ...
    def offsetCutter(self, arg0: float) -> MillingCutter:
        ...
    def pushCutter(self, arg0: Fiber, arg1: Interval, arg2: Triangle) -> bool:
        ...
    def vertexDrop(self, arg0: CLPoint, arg1: Triangle) -> bool:
        ...
class Path:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Path) -> None:
        ...
    @typing.overload
    def append(self, arg0: Line) -> None:
        ...
    @typing.overload
    def append(self, arg0: Arc) -> None:
        ...
    def getSpans(self) -> list:
        ...
    def getTypeSpanPairs(self) -> list:
        ...
class PathDropCutter:
    minimumZ: float
    def __init__(self) -> None:
        ...
    def getCLPoints(self) -> list[CLPoint]:
        ...
    def getZ(self) -> float:
        ...
    def run(self) -> None:
        ...
    def setCutter(self, arg0: MillingCutter) -> None:
        ...
    def setPath(self, arg0: Path) -> None:
        ...
    def setSTL(self, arg0: STLSurf) -> None:
        ...
    def setSampling(self, arg0: float) -> None:
        ...
    def setZ(self, arg0: float) -> None:
        ...
class Point:
    x: float
    y: float
    z: float
    def __add__(self, arg0: Point) -> Point:
        ...
    def __iadd__(self, arg0: Point) -> Point:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Point) -> None:
        ...
    def __isub__(self, arg0: Point) -> Point:
        ...
    def __mul__(self, arg0: float) -> Point:
        ...
    def __rmul__(self, arg0: float) -> Point:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Point) -> Point:
        ...
    def cross(self, arg0: Point) -> Point:
        ...
    def dot(self, arg0: Point) -> float:
        ...
    @typing.overload
    def isInside(self, arg0: Triangle) -> bool:
        ...
    @typing.overload
    def isInside(self, arg0: Point, arg1: Point) -> bool:
        ...
    def isRight(self, arg0: Point, arg1: Point) -> bool:
        ...
    def norm(self) -> float:
        ...
    def normalize(self) -> None:
        ...
    def xRotate(self, arg0: float) -> None:
        ...
    def xyDistance(self, arg0: Point) -> float:
        ...
    def xyNorm(self) -> float:
        ...
    def yRotate(self, arg0: float) -> None:
        ...
    def zRotate(self, arg0: float) -> None:
        ...
class STLReader:
    def __init__(self, arg0: str, arg1: STLSurf) -> None:
        ...
class STLSurf:
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        ...
    def addTriangle(self, arg0: Triangle) -> None:
        ...
    def getBounds(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    def getTriangles(self) -> list[Triangle]:
        ...
    def rotate(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    def size(self) -> int:
        ...
    @property
    def bb(self) -> Bbox:
        ...
    @property
    def tris(self) -> list[Triangle]:
        ...
class SimpleWeave(Weave):
    def __init__(self) -> None:
        ...
class SmartWeave(Weave):
    def __init__(self) -> None:
        ...
class SpanType:
    """
    Members:
    
      LineSpanType
    
      ArcSpanType
    """
    ArcSpanType: typing.ClassVar[SpanType]  # value = <SpanType.ArcSpanType: 1>
    LineSpanType: typing.ClassVar[SpanType]  # value = <SpanType.LineSpanType: 0>
    __members__: typing.ClassVar[dict[str, SpanType]]  # value = {'LineSpanType': <SpanType.LineSpanType: 0>, 'ArcSpanType': <SpanType.ArcSpanType: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TSPSolver:
    def __init__(self) -> None:
        ...
    def addPoint(self, arg0: float, arg1: float) -> None:
        ...
    def getLength(self) -> float:
        ...
    def getOutput(self) -> list[int]:
        ...
    def reset(self) -> None:
        ...
    def run(self) -> None:
        ...
class Triangle:
    def __init__(self, arg0: Point, arg1: Point, arg2: Point) -> None:
        ...
    def __str__(self) -> str:
        ...
    def getPoints(self) -> typing.Annotated[list[Point], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def n(self) -> Point:
        ...
    @property
    def p(self) -> typing.Annotated[list[Point], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Waterline:
    def __init__(self) -> None:
        ...
    def getLoops(self) -> list[list[Point]]:
        ...
    def getThreads(self) -> int:
        ...
    def getXFibers(self) -> list[Fiber]:
        ...
    def getYFibers(self) -> list[Fiber]:
        ...
    def reset(self) -> None:
        ...
    def run(self) -> None:
        ...
    def run2(self) -> None:
        ...
    def setCutter(self, arg0: MillingCutter) -> None:
        ...
    def setSTL(self, arg0: STLSurf) -> None:
        ...
    def setSampling(self, arg0: float) -> None:
        ...
    def setThreads(self, arg0: int) -> None:
        ...
    def setZ(self, arg0: float) -> None:
        ...
class Weave:
    def __str__(self) -> str:
        ...
    def addFiber(self, arg0: Fiber) -> None:
        ...
    def build(self) -> None:
        ...
    def face_traverse(self) -> None:
        ...
    def getCLVertices(self) -> list[Point]:
        ...
    def getEdges(self) -> list[tuple[Point, Point]]:
        ...
    def getINTVertices(self) -> list[Point]:
        ...
    def getLoops(self) -> list[list[Point]]:
        ...
    def getVertices(self) -> list[Point]:
        ...
    def getVerticesByType(self, arg0: WeaveVertexType) -> list[Point]:
        ...
    def numVertices(self) -> int:
        ...
    def printGraph(self) -> None:
        ...
class WeaveVertexType:
    """
    Members:
    
      CL
    
      CL_DONE
    
      ADJ
    
      TWOADJ
    
      INT
    
      FULLINT
    """
    ADJ: typing.ClassVar[WeaveVertexType]  # value = <WeaveVertexType.ADJ: 2>
    CL: typing.ClassVar[WeaveVertexType]  # value = <WeaveVertexType.CL: 0>
    CL_DONE: typing.ClassVar[WeaveVertexType]  # value = <WeaveVertexType.CL_DONE: 1>
    FULLINT: typing.ClassVar[WeaveVertexType]  # value = <WeaveVertexType.FULLINT: 5>
    INT: typing.ClassVar[WeaveVertexType]  # value = <WeaveVertexType.INT: 4>
    TWOADJ: typing.ClassVar[WeaveVertexType]  # value = <WeaveVertexType.TWOADJ: 3>
    __members__: typing.ClassVar[dict[str, WeaveVertexType]]  # value = {'CL': <WeaveVertexType.CL: 0>, 'CL_DONE': <WeaveVertexType.CL_DONE: 1>, 'ADJ': <WeaveVertexType.ADJ: 2>, 'TWOADJ': <WeaveVertexType.TWOADJ: 3>, 'INT': <WeaveVertexType.INT: 4>, 'FULLINT': <WeaveVertexType.FULLINT: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ZigZag:
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        ...
    def addPoint(self, arg0: Point) -> None:
        ...
    def getOutput(self) -> list[Point]:
        ...
    def run(self) -> None:
        ...
    def setDirection(self, arg0: Point) -> None:
        ...
    def setOrigin(self, arg0: Point) -> None:
        ...
    def setStepOver(self, arg0: float) -> None:
        ...
def eps() -> float:
    """
    machine epsilon, see numeric.cpp
    """
def epsD(arg0: float) -> float:
    ...
def epsF(arg0: float) -> float:
    ...
def max_threads() -> int:
    """
    Return the maximum number of available threads
    """
def version() -> str:
    """
    Return the version string of OpenCAMLib
    """
ArcSpanType: SpanType  # value = <SpanType.ArcSpanType: 1>
EDGE: CCType  # value = <CCType.EDGE: 3>
EDGE_BALL: CCType  # value = <CCType.EDGE_BALL: 8>
EDGE_CONE: CCType  # value = <CCType.EDGE_CONE: 12>
EDGE_CONE_BASE: CCType  # value = <CCType.EDGE_CONE_BASE: 13>
EDGE_CYL: CCType  # value = <CCType.EDGE_CYL: 11>
EDGE_HORIZ: CCType  # value = <CCType.EDGE_HORIZ: 4>
EDGE_HORIZ_CYL: CCType  # value = <CCType.EDGE_HORIZ_CYL: 6>
EDGE_HORIZ_TOR: CCType  # value = <CCType.EDGE_HORIZ_TOR: 7>
EDGE_NEG: CCType  # value = <CCType.EDGE_NEG: 10>
EDGE_POS: CCType  # value = <CCType.EDGE_POS: 9>
EDGE_SHAFT: CCType  # value = <CCType.EDGE_SHAFT: 5>
ERROR: CCType  # value = <CCType.ERROR: 17>
FACET: CCType  # value = <CCType.FACET: 14>
FACET_CYL: CCType  # value = <CCType.FACET_CYL: 16>
FACET_TIP: CCType  # value = <CCType.FACET_TIP: 15>
LineSpanType: SpanType  # value = <SpanType.LineSpanType: 0>
NONE: CCType  # value = <CCType.NONE: 0>
VERTEX: CCType  # value = <CCType.VERTEX: 1>
VERTEX_CYL: CCType  # value = <CCType.VERTEX_CYL: 2>
